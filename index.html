<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>CodePen - Three.js 3D Model Import</title>
<style>
/* **************
Created using a tutorial from Redstapler
GLTF 3D Model from Shaw Pen https://codepen.io/shshaw/pen/yPPOEg
************** */
#hotspotsToggle { position: absolute; top: 10px; left: 10px; padding: 10px; cursor: pointer; }
body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  overflow: hidden;	
}
body {
  overflow: hidden;
  margin: 0;
}
body {
				color: #444;
			}
			a {
				color: #08f;
			}
.hud {
		display: block;
		position: absolute;
		left: 100px;
		top: 100px;
		background: none;
		border: none;
		border-radius: 1em;
		text-align: center;
		font-family: sans-serif;
		font-size: 150%;
		padding: 20px;
}

.hud:hover {
		cursor: pointer;
		border: solid 1px gray;
		background: rgba( 255, 255, 255, 0.5 );
}
	
}
.annotation {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
    margin-left: 15px;
    margin-top: 15px;
    padding: 1em;
    width: 200px;
    color: #fff;
    background: rgba(0, 0, 0, 0.8);
    border-radius: .5em;
    font-size: 12px;
    line-height: 1.2;
    transition: opacity .5s;
    &::before {
        content: '1';
        position: absolute;
        top: -30px;
        left: -30px;
        width: 30px;
        height: 30px;
        border: 2px solid #fff;
        border-radius: 50%;
        font-size: 16px;
        line-height: 30px;
        text-align: center;
        background: rgba(0, 0, 0, 0.8);
    }
}

#number {
    position: absolute;
    z-index: -1;
}	
</style>
</head>
<body>
<div id="hotspotsToggle" onclick="toggleHotspots()">Toggle Hotspots</div>	
<!-- partial:index.partial.html -->
<!-- **************
Created using a tutorial from Redstapler
GLTF 3D Model from Shaw Pen https://codepen.io/shshaw/pen/yPPOEg
************** -->
<div class="annotation annotation1">
    <div class="box box1">
        <div class="circleMark circleMark1">1</div>
        
    </div>
</div>	
<script>console.clear();</script>
<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>	
<!-- partial -->
 <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.1/dist/es-module-shims.js" crossorigin="anonymous"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.149.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.149.0/examples/jsm/"
    }
  }
</script> 
<script src='three.js'></script>
<script src='https://unpkg.com/three@0.108.0/examples/js/controls/OrbitControls.js'></script>
<script src='https://unpkg.com/three@0.108.0/examples/js/loaders/GLTFLoader.js'></script>
<script src='https://raw.githubusercontent.com/mrdoob/three.js/master/examples/jsm/environments/RoomEnvironment.js'></script>
<script>
// Created using a tutorial from Redstapler
// GLTF 3D Model from Shaw Pen https://codepen.io/shshaw/pen/yPPOEg

// Three JS needs mainly below three things

/* //////////////////////////////////////// */

var hotspotsEnabled = true;

// SCENE
var scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

/* //////////////////////////////////////// */

// CAMERA
var camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 800 );
camera.position.set(0,0,0);


/* ////////////////////////////////////////// */

// RENDERER
var renderer = new THREE.WebGLRenderer( { antialias: true } );
renderer.setPixelRatio( window.devicePixelRatio );	
renderer.setSize( window.innerWidth, window.innerHeight );



scene.background = new THREE.Color( 0xbfe3dd );
//scene.environment = pmremGenerator.fromScene( new RoomEnvironment( renderer ), 0.04 ).texture;
	

// Append canvas to the body
document.body.appendChild( renderer.domElement);

/* ////////////////////////////////////////// */

// Camera Rotation Control
var controls = new THREE.OrbitControls( camera, renderer.domElement);

controls.rotateSpeed = 0.1;
controls.zoomSpeed = 0.9;

controls.minDistance = 3;
controls.maxDistance = 3;

controls.minPolarAngle = 0; // radians
controls.maxPolarAngle = Math.PI /2; // radians

controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enablePan = false;




	
   


/* /////////////////////////////////////////////// */

// Point Light

const hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 2 );
hemiLight.color.setHSL( 0.6, 1, 0.6 );
hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
hemiLight.position.set( 0, 50, 0 );
scene.add( hemiLight );
const hemiLightHelper = new THREE.HemisphereLightHelper( hemiLight, 10 );
scene.add( hemiLightHelper );	
var light = new THREE.PointLight( 0xffffcc,1, 5 );
light.position.set( 4, 30, -20 );
scene.add( light );
const dirLight = new THREE.DirectionalLight( 0xffffff, 3 );
				dirLight.color.setHSL( 0.1, 1, 0.95 );
				dirLight.position.set( - 1, 1.75, 1 );
				dirLight.position.multiplyScalar( 30 );
				scene.add( dirLight );

				dirLight.castShadow = true;

				dirLight.shadow.mapSize.width = 2048;
				dirLight.shadow.mapSize.height = 2048;

				const d = 50;

				dirLight.shadow.camera.left = - d;
				dirLight.shadow.camera.right = d;
				dirLight.shadow.camera.top = d;
				dirLight.shadow.camera.bottom = - d;

				dirLight.shadow.camera.far = 3500;
				dirLight.shadow.bias = - 0.0001;

				const dirLightHelper = new THREE.DirectionalLightHelper( dirLight, 10 );
				scene.add( dirLightHelper );

	
var light2 = new THREE.AmbientLight( 0x20202A, 20, 10 );
light2.position.set( 30, -10, 30 );
scene.add( light2 );

/* ////////////////////////////////////////// */

// GLTF Loader to Load and manipulate 3D Models
var loader = new THREE.GLTFLoader();

loader.crossOrigin = true;

loader.load( 'https://s3-us-west-2.amazonaws.com/s.cdpn.io/39255/ladybug.gltf', function ( data ) {
    var object = data.scene;
     object.position.set(0, -10, -0.1);
     
     //object.scale.set(0.5,0.5,0.5);
    scene.add( object );
addHotspot(model, 1, 2, 3);

                // Adjust model position, rotation, and scale if needed
                model.position.set(0, 0, 0);
                model.rotation.set(0, 0, 0);
                model.scale.set(1, 1, 1);
    createMarker(model, new Vector3(0,17,8))
    createMarker(model, new Vector3(4,15,1.7))
    createMarker(model, new Vector3(-6,0,4))	
loader.rotation.x = Math.PI/4;
loader.rotation.y = Math.PI/4;	
});

  var loader1 = new THREE.GLTFLoader();

loader1.crossOrigin = true;

loader1.load( 'Room_t.glb', function ( data ) {
    var object = data.scene;
     object.position.set(0, 0, 0);
     object.scale.set(1,1,1);
     	
    scene.add( object );
loader1.rotation.x = Math.PI/4;
loader1.rotation.y = Math.PI/4;	


const numberTexture = new THREE.CanvasTexture(
    document.querySelector('#number')
);

const spriteMaterial = new THREE.SpriteMaterial({
    map: numberTexture,
    alphaTest: 0.5,
    transparent: true,
    depthTest: false,
    depthWrite: false
});

sprite = new THREE.Sprite(spriteMaterial);
sprite.position.set(250, 250, 250);
sprite.scale.set(35, 35, 1);

scene.add(sprite);	
});
	
/* //////////////////////////////////////// */

// Render animation on every rendering phase
function render () {
  requestAnimationFrame( render ); 
  renderer.render( scene, camera ); // Render Scene and Camera
  controls.update(); // For Orbit Controller
}

render();

/*////////////////////////////////////////*/

// Update Camera Aspect Ratio and Renderer ScreenSize on Window resize
window.addEventListener( 'resize', function () {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}, false );


	
function updateAnnotationOpacity() {
    const meshDistance = camera.position.distanceTo(mesh.position);
    const spriteDistance = camera.position.distanceTo(sprite1.position);
    spriteBehindObject = spriteDistance > meshDistance;
    sprite1.material.opacity = spriteBehindObject ? 0.25 : 1;
    sprite1.material.opacity = 0;
  
    const meshDistance2 = camera.position.distanceTo(mesh.position);
    const spriteDistance2 = camera.position.distanceTo(sprite2.position);
    spriteBehindObject2 = spriteDistance2 > meshDistance2;
    sprite2.material.opacity = spriteBehindObject2 ? 0.25 : 1;
    sprite2.material.opacity = 0; // sprite2透明度
}

function updateScreenPosition() {
    const vector_1 = new THREE.Vector3(200, 200, -100);
    const vector_2 = new THREE.Vector3(-200, -100, 250);
}
    
/*////////////////////////////////////////*/
function addHotspot(parent, x, y, z) {
            var hotspotGeometry = new THREE.BoxGeometry(1, 1, 1);
            var hotspotMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });
            var hotspotMesh = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            hotspotMesh.position.set(10,10, 0);
            parent.add(hotspotMesh);

            hotspotMesh.userData.onClick = function () {
                console.log('Hotspot clicked!');
                // Add your hotspot click logic here
            };
        }

        function onMouseClick(event) {
            if (!hotspotsEnabled) return;

            event.preventDefault();

            var raycaster = new THREE.Raycaster();
            var mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                var clickedObject = intersects[0].object;
                if (clickedObject.userData.onClick) {
                    clickedObject.userData.onClick();
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function toggleHotspots() {
            hotspotsEnabled = !hotspotsEnabled;
        }

        window.addEventListener('resize', function () {
            var newWidth = window.innerWidth;
            var newHeight = window.innerHeight;

            camera.aspect = newWidth / newHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(newWidth, newHeight);
        });

function createMarker(model, position) {
  const loader = new TextureLoader();
  loader.crossOrigin = "";
  const map = loader.load("https://i.imgur.com/EZynrrA.png");
  map.encoding = sRGBEncoding
  
  const spriteMaterialFront = new SpriteMaterial( { map } );
  
  const spriteFront = new Sprite( spriteMaterialFront );
  spriteFront.position.copy(position) 
  
  const spriteMaterialRear = new SpriteMaterial({ 
    map,
    opacity: 0.3, 
    transparent: true, 
    depthTest: false
  });
  
  const spriteRear = new Sprite( spriteMaterialRear );
  spriteRear.position.copy(position) 
  
  model.add(spriteFront, spriteRear)
}
	</script>

</body>
</html>
